#!/bin/bash
set -e 
set -o pipefail

# version="0.1"
#
# This is an optional arguments-only example of Argbash potential
#
# ARG_OPTIONAL_SINGLE([data_dir],[D],[],["data/nmt/messages_nnsplit"])
# ARG_OPTIONAL_SINGLE([model_path],[M],[],["models/sp_model"])
# ARG_OPTIONAL_SINGLE([vocab_size],[S],[],[24000])
# ARG_OPTIONAL_SINGLE([model_type],[T],[],["bpe"])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

# # When called, the process ends.
# Args:
# 	$1: The exit message (print to stderr)
# 	$2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to $1)
# Example:
# 	test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die() {
    local _ret="${2:-1}"
    test "${_PRINT_HELP:-no}" = yes && print_help >&2
    echo "$1" >&2
    exit "${_ret}"
}

# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option() {
    local first_option all_short_options='DMST'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_data_dir="data/nmt/messages_nnsplit_14799"
_arg_model_path="models/sp_model"
_arg_vocab_size="24000"
_arg_model_type="unigram"

# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help() {
    printf 'Usage: %s [-D|--data_dir <arg>] [-M|--model_path <arg>] [-S|--vocab_size <arg>] [-T|--model_type <arg>]\n' "$0"
}

# The parsing of the command-line
parse_commandline() {
    while test $# -gt 0; do
        _key="$1"
        case "$_key" in
        # We support whitespace as a delimiter between option argument and its value.
        # Therefore, we expect the --data_dir or -D value.
        # so we watch for --data_dir and -D.
        # Since we know that we got the long or short option,
        # we just reach out for the next argument to get the value.
        -D | --data_dir)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_data_dir="$2"
            shift
            ;;
        # We support the = as a delimiter between option argument and its value.
        # Therefore, we expect --data_dir=value, so we watch for --data_dir=*
        # For whatever we get, we strip '--data_dir=' using the ${var##--data_dir=} notation
        # to get the argument value
        --data_dir=*)
            _arg_data_dir="${_key##--data_dir=}"
            ;;
        # We support getopts-style short arguments grouping,
        # so as -D accepts value, we allow it to be appended to it, so we watch for -D*
        # and we strip the leading -D from the argument string using the ${var##-D} notation.
        -D*)
            _arg_data_dir="${_key##-D}"
            ;;
        # See the comment of option '--data_dir' to see what's going on here - principle is the same.
        -M | --model_path)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_model_path="$2"
            shift
            ;;
        # See the comment of option '--data_dir=' to see what's going on here - principle is the same.
        --model_path=*)
            _arg_model_path="${_key##--model_path=}"
            ;;
        # See the comment of option '-D' to see what's going on here - principle is the same.
        -M*)
            _arg_model_path="${_key##-M}"
            ;;
        # See the comment of option '--data_dir' to see what's going on here - principle is the same.
        -S | --vocab_size)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_vocab_size="$2"
            shift
            ;;
        # See the comment of option '--data_dir=' to see what's going on here - principle is the same.
        --vocab_size=*)
            _arg_vocab_size="${_key##--vocab_size=}"
            ;;
        # See the comment of option '-D' to see what's going on here - principle is the same.
        -S*)
            _arg_vocab_size="${_key##-S}"
            ;;
        # See the comment of option '--data_dir' to see what's going on here - principle is the same.
        -T | --model_type)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_model_type="$2"
            shift
            ;;
        # See the comment of option '--data_dir=' to see what's going on here - principle is the same.
        --model_type=*)
            _arg_model_type="${_key##--model_type=}"
            ;;
        # See the comment of option '-D' to see what's going on here - principle is the same.
        -T*)
            _arg_model_type="${_key##-T}"
            ;;
        *)
            _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
            ;;
        esac
        shift
    done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

spm_train \
    --input=<(cat ${_arg_data_dir}/train.src ${_arg_data_dir}/train.trg) \
    --model_prefix=${_arg_model_path} \
    --vocab_size=${_arg_vocab_size} \
    --model_type=${_arg_model_type}

for f in $(find ${_arg_data_dir} | grep -P './\w+.(src|trg)$'); do
    echo "$f > ${f%.*}.sp.${f##*.}"
    spm_encode --model=${_arg_model_path}.model $f >${f%.*}.sp.${f##*.}
done

python3 lib/joeynmt/scripts/build_vocab.py \
    ${_arg_data_dir}/train.sp.src \
    ${_arg_data_dir}/train.sp.trg \
    --output_path=${_arg_data_dir}/vocab.txt

# ] <-- needed because of Argbash
